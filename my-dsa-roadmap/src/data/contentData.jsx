// import React from 'react';
// import { Github, ShieldQuestion, Code } from "lucide-react";

// export function getDetailedNodeContent(nodeId) {
//     const content = {
//         root: (<div><div className="space-y-2"><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> What is this?</h3><p className="text-gray-600">This is an interactive mindmap designed to help you master the core patterns of Data Structures and Algorithms. Instead of memorizing solutions, learn the underlying techniques that solve entire classes of problems.</p></div><div className="pt-4"><a href="https://github.com/satyam0777/DSA-Placement/tree/main" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 px-3 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors text-sm font-medium shadow-sm"><Github className="w-4 h-4" /> View original project on GitHub</a></div></div>),
//         arrays: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Arrays store elements in contiguous memory, enabling instant O(1) access by index. This makes sequential iteration exceptionally fast due to CPU caching. A string is essentially an immutable array of characters.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Two Pointers:</strong> Using two indices to iterate, find pairs, or reverse.</li><li><strong>Sliding Window:</strong> A dynamic subarray to find optimal ranges.</li><li><strong>Prefix Sum:</strong> Pre-calculating sums for rapid range sum queries.</li></ul></div></div>),
//         hashing: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Hash Tables (or Hash Maps) use a hash function to map keys to indices in an array, providing average-case O(1) time for insertions, deletions, and lookups. They are essential for frequency counting and quick data retrieval.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Frequency Counting:</strong> Tracking occurrences of elements.</li><li><strong>Two-Sum Pattern:</strong> Finding pairs that sum to a target by checking for `target - current` in the map.</li><li><strong>Caching/Memoization:</strong> Storing results of expensive computations.</li></ul></div></div>),
//         trees: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Trees are hierarchical data structures with a root node and child nodes. Key types include Binary Trees (max two children) and Binary Search Trees (ordered children). Traversal is key: BFS explores level-by-level, while DFS explores branch-by-branch.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Depth-First Search (DFS):</strong> In-order, Pre-order, Post-order traversals.</li><li><strong>Breadth-First Search (BFS):</strong> Level-order traversal, finds shortest paths.</li><li><strong>Recursion:</strong> Most tree problems have elegant recursive solutions.</li></ul></div></div>),
//         dynamic: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Dynamic Programming (DP) is an optimization technique for solving complex problems by breaking them down into simpler, overlapping subproblems. Solutions to subproblems are stored to avoid redundant calculations.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Memoization (Top-Down):</strong> A recursive approach where you cache results.</li><li><strong>Tabulation (Bottom-Up):</strong> An iterative approach where you build a table of solutions from the base case up.</li></ul></div></div>),
//         search: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">This category focuses on efficient searching and sorting algorithms. The most critical pattern is Binary Search, a powerful "divide and conquer" strategy that works on sorted collections to find elements in logarithmic time.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Binary Search:</strong> Halving the search space in each step.</li><li><strong>Sorting Algorithms:</strong> Understanding trade-offs of Merge Sort, Quick Sort, etc.</li></ul></div></div>),
//         twoptr: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">A versatile pattern using two pointers to iterate through a data structure. It's highly efficient, often reducing time complexity from O(n²) to O(n) and using O(1) space.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Variations</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Opposite Ends:</strong> Pointers start at the beginning and end, moving inward.</li><li><strong>Fast & Slow:</strong> Pointers move at different speeds, often to detect cycles.</li></ul></div></div>),
//         sliding: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">The Sliding Window pattern involves creating a "window" (a sub-array or sub-string) that slides through the data. It's used to efficiently find a contiguous section that satisfies a given condition, avoiding nested loops.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Variations</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Fixed Size Window:</strong> The window size remains constant.</li><li><strong>Dynamic Size Window:</strong> The window grows and shrinks based on conditions.</li></ul></div></div>),
//         backtrack: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Backtracking is a recursive technique for solving problems by trying to build a solution incrementally. If an option doesn't lead to a solution, it "backtracks" to try another path. It's a form of brute-force, but intelligently pruned.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Mantra</h3><p className="text-gray-600 mt-1">"Choose, Explore, Unchoose". This framework is key to solving permutation, combination, and subset problems.</p></div></div>),
//         heap: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">A Heap is a tree-based data structure that satisfies the heap property (e.g., in a min-heap, every parent is smaller than its children). It's primarily used to implement Priority Queues for efficient retrieval of the min/max element.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Use Cases</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li>Finding the "Top K" elements in a collection.</li><li>Finding the median in a stream of numbers.</li><li>Implementing Dijkstra's shortest path algorithm.</li></ul></div></div>),
//     };
//     return content[nodeId] || <div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">{`Details for this pattern are coming soon! This topic covers ${nodeId.replace(/^\w/, c => c.toUpperCase())}.`}</p></div></div>;
// }



import React from 'react';
import { Github, ShieldQuestion, Code } from "lucide-react";

// This file provides static JSX content for the details panel.
// It's kept on the frontend as it's part of the UI presentation.

export function getDetailedNodeContent(nodeId) {
    const content = {
        root: (<div><div className="space-y-2"><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> What is this?</h3><p className="text-gray-600">This is an interactive mindmap designed to help you master the core patterns of Data Structures and Algorithms. Instead of memorizing solutions, learn the underlying techniques that solve entire classes of problems.</p></div><div className="pt-4"><a href="https://github.com/satyam0777/DSA-Placement/tree/main" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 px-3 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors text-sm font-medium shadow-sm"><Github className="w-4 h-4" /> View original project on GitHub</a></div></div>),
        arrays: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Arrays store elements in contiguous memory, enabling instant O(1) access by index. This makes sequential iteration exceptionally fast due to CPU caching. A string is essentially an immutable array of characters.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Two Pointers:</strong> Using two indices to iterate, find pairs, or reverse.</li><li><strong>Sliding Window:</strong> A dynamic subarray to find optimal ranges.</li><li><strong>Prefix Sum:</strong> Pre-calculating sums for rapid range sum queries.</li></ul></div></div>),
        hashing: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Hash Tables (or Hash Maps) use a hash function to map keys to indices in an array, providing average-case O(1) time for insertions, deletions, and lookups. They are essential for frequency counting and quick data retrieval.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Frequency Counting:</strong> Tracking occurrences of elements.</li><li><strong>Two-Sum Pattern:</strong> Finding pairs that sum to a target by checking for `target - current` in the map.</li><li><strong>Caching/Memoization:</strong> Storing results of expensive computations.</li></ul></div></div>),
        trees: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Trees are hierarchical data structures with a root node and child nodes. Key types include Binary Trees (max two children) and Binary Search Trees (ordered children). Traversal is key: BFS explores level-by-level, while DFS explores branch-by-branch.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Depth-First Search (DFS):</strong> In-order, Pre-order, Post-order traversals.</li><li><strong>Breadth-First Search (BFS):</strong> Level-order traversal, finds shortest paths.</li><li><strong>Recursion:</strong> Most tree problems have elegant recursive solutions.</li></ul></div></div>),
        dynamic: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Dynamic Programming (DP) is an optimization technique for solving complex problems by breaking them down into simpler, overlapping subproblems. Solutions to subproblems are stored to avoid redundant calculations.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Memoization (Top-Down):</strong> A recursive approach where you cache results.</li><li><strong>Tabulation (Bottom-Up):</strong> An iterative approach where you build a table of solutions from the base case up.</li></ul></div></div>),
        search: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">This category focuses on efficient searching and sorting algorithms. The most critical pattern is Binary Search, a powerful "divide and conquer" strategy that works on sorted collections to find elements in logarithmic time.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Techniques</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Binary Search:</strong> Halving the search space in each step.</li><li><strong>Sorting Algorithms:</strong> Understanding trade-offs of Merge Sort, Quick Sort, etc.</li></ul></div></div>),
        twoptr: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">A versatile pattern using two pointers to iterate through a data structure. It's highly efficient, often reducing time complexity from O(n²) to O(n) and using O(1) space.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Variations</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Opposite Ends:</strong> Pointers start at the beginning and end, moving inward.</li><li><strong>Fast & Slow:</strong> Pointers move at different speeds, often to detect cycles.</li></ul></div></div>),
        sliding: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">The Sliding Window pattern involves creating a "window" (a sub-array or sub-string) that slides through the data. It's used to efficiently find a contiguous section that satisfies a given condition, avoiding nested loops.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Variations</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li><strong>Fixed Size Window:</strong> The window size remains constant.</li><li><strong>Dynamic Size Window:</strong> The window grows and shrinks based on conditions.</li></ul></div></div>),
        backtrack: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">Backtracking is a recursive technique for solving problems by trying to build a solution incrementally. If an option doesn't lead to a solution, it "backtracks" to try another path. It's a form of brute-force, but intelligently pruned.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Mantra</h3><p className="text-gray-600 mt-1">"Choose, Explore, Unchoose". This framework is key to solving permutation, combination, and subset problems.</p></div></div>),
        heap: (<div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">A Heap is a tree-based data structure that satisfies the heap property (e.g., in a min-heap, every parent is smaller than its children). It's primarily used to implement Priority Queues for efficient retrieval of the min/max element.</p></div><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><Code/> Common Use Cases</h3><ul className="list-disc list-inside text-gray-600 mt-1 space-y-1"><li>Finding the "Top K" elements in a collection.</li><li>Finding the median in a stream of numbers.</li><li>Implementing Dijkstra's shortest path algorithm.</li></ul></div></div>),
    };
    return content[nodeId] || <div className="space-y-4"><div><h3 className="font-semibold text-gray-800 flex items-center gap-2"><ShieldQuestion/> Core Concepts</h3><p className="text-gray-600 mt-1">{`Details for this pattern are coming soon! This topic covers ${nodeId.replace(/^\w/, c => c.toUpperCase())}.`}</p></div></div>;
}

